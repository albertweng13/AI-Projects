def evaluationFunction(self, currentGameState, action):
        """
        Design a better evaluation function here.

        The evaluation function takes in the current and proposed successor
        GameStates (pacman.py) and returns a number, where higher numbers are better.

        The code below extracts some useful information from the state, like the
        remaining food (newFood) and Pacman position after moving (newPos).
        newScaredTimes holds the number of moves that each ghost will remain
        scared because of Pacman having eaten a power pellet.

        Print out these variables to see what you're getting, then combine them
        to create a masterful evaluation function.
        """
        # Useful information you can extract from a GameState (pacman.py)
        successorGameState = currentGameState.generatePacmanSuccessor(action)
        newPos = successorGameState.getPacmanPosition()
        newFood = currentGameState.getFood().asList()
        newGhostStates = successorGameState.getGhostStates()
        newScaredTimes = [ghostState.scaredTimer for ghostState in newGhostStates]
        ghostpositions = successorGameState.getGhostPositions()

        def distance(tuple1, tuple2):
          tuple1 = (float(tuple1[0]), float(tuple1[1]))
          tuple2 = (float(tuple2[0]), float(tuple2[1]))
          return float(math.sqrt(math.pow(tuple1[0] - tuple2[0],2) + math.pow(tuple1[1] - tuple2[1], 2)))

        ghost_score = 0.0
        print("newPos: " + str(newPos))
        for elem in ghostpositions:
          if distance(newPos, elem) <= 1:
            return -1000
          elem = (int(elem[0]),int(elem[1]))
          newPos = (int(newPos[0]), int(newPos[1]))
          temp = mazeDistance(elem, newPos, successorGameState)
          if temp != 0:
            ghost_score = ghost_score + ((float(0.01) / temp) * -1)
          else:
            ghost_score = -1000

        max_tuple = (0.0, "yoloswag")
        food_score = 0.0
        for elem in newFood:   
          temp = mazeDistance(elem, newPos, successorGameState)
          print("food_temp: " + str(temp) + " location: " + str(elem)) 
          if temp != 0:
            food_score = ((float(0.1) / temp) * 1)
          else:
            food_score = 1000.0
          if food_score > max_tuple[0]:
            max_tuple = (food_score, elem)
        print("max_score: " + str(max_tuple[0]))
        print("ghost_score: " + str(ghost_score))
        """if max_tuple[0] > ghost_score:
          print("returned: " + str(max_tuple[0]))
          return max_tuple[0]
        else:
          print("returned: " + str(ghost_score))
          return ghost_score """
        return max_tuple[0] + ghost_score